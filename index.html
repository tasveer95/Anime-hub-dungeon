<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Hub → Dungeon (Keyboard Only)</title>
  <style>
    :root{
      --bg:#070A12;
      --glass: rgba(10,14,26,0.70);
      --stroke: rgba(255,255,255,0.14);
      --text: rgba(235,241,255,0.92);
      --muted: rgba(235,241,255,0.68);
      --good: rgba(102,242,185,0.96);
      --gold: rgba(255,208,102,0.96);
      --shadow: 0 18px 55px rgba(0,0,0,0.45);
      --r: 18px;
    }
    html,body{height:100%; margin:0; background: radial-gradient(1100px 800px at 35% 20%, #203070 0%, var(--bg) 55%); color:var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; overflow:hidden;}
    #wrap{position:relative; width:100vw; height:100vh;}
    canvas{display:block; width:100%; height:100%; outline:none;}
    #hud{
      position:absolute; left:16px; top:16px; width:380px;
      background: var(--glass);
      border:1px solid var(--stroke);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      padding:14px;
      user-select:none;
      z-index:60;
    }
    .hudTitle{display:flex; justify-content:space-between; align-items:center; font-weight:800;}
    .chip{padding:6px 10px; border-radius:999px; border:1px solid var(--stroke); background: rgba(255,255,255,0.05); color:var(--muted); font-size:12px;}
    .barWrap{margin-top:10px; padding:10px; border-radius:14px; border:1px solid var(--stroke); background: rgba(255,255,255,0.05);}
    .barLabel{font-size:12px; color:var(--muted); margin-bottom:6px;}
    .hpBar{height:12px; border-radius:999px; background: rgba(255,255,255,0.08); overflow:hidden; border:1px solid rgba(255,255,255,0.10);}
    .hpFill{height:100%; width:100%; background: linear-gradient(90deg, rgba(255,90,90,0.95), rgba(102,242,185,0.95));}
    .row{display:flex; gap:10px; margin-top:10px; flex-wrap:wrap;}
    .card{flex:1; min-width:170px; padding:10px; border-radius:14px; border:1px solid var(--stroke); background: rgba(255,255,255,0.05);}
    .k{font-size:12px; color:var(--muted); margin-bottom:4px;}
    .v{font-size:16px; font-weight:800; display:flex; align-items:center; gap:8px;}
    .hint{margin-top:10px; font-size:12px; color:var(--muted); line-height:1.35;}
    .good{color:var(--good); font-weight:800;}
    .gold{color:var(--gold); font-weight:800;}
    #msg{
      position:absolute; left:50%; top:16px; transform:translateX(-50%);
      padding:10px 14px; border-radius:16px;
      border:1px solid var(--stroke);
      background: rgba(10,14,26,0.55);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      color: var(--muted); font-weight:700;
      z-index:60; opacity:0; transition:opacity .18s ease;
      pointer-events:none;
      width:min(620px, calc(100vw - 30px));
      text-align:center;
    }
    #msg.show{opacity:1;}
  </style>
</head>
<body>
<div id="wrap">
  <div id="msg"></div>

  <div id="hud">
    <div class="hudTitle">
      <div>Prototype</div>
      <div class="chip" id="zoneChip">Zone: Start</div>
    </div>

    <div class="barWrap">
      <div class="barLabel">HP <span class="gold" id="hpText">10/10</span></div>
      <div class="hpBar"><div class="hpFill" id="hpFill"></div></div>
    </div>

    <div class="row">
      <div class="card">
        <div class="k">Resources</div>
        <div class="v"><span class="gold" id="woodText">0</span> wood · <span class="gold" id="stoneText">0</span> stone</div>
      </div>
      <div class="card">
        <div class="k">Controls</div>
        <div class="v" style="font-size:14px">
          <span class="good">WASD / Arrows</span>
        </div>
      </div>
    </div>

    <div class="hint">
      Sprint: <span class="good">Shift</span> · Attack: <span class="good">Space</span><br/>
      Walk into the <span class="gold">glowing portal</span> to enter the dungeon.
    </div>
  </div>
</div>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script>
(() => {
  const ui = {
    zoneChip: document.getElementById("zoneChip"),
    hpText: document.getElementById("hpText"),
    hpFill: document.getElementById("hpFill"),
    woodText: document.getElementById("woodText"),
    stoneText: document.getElementById("stoneText"),
    msg: document.getElementById("msg"),
  };

  function toast(t){
    ui.msg.textContent = t;
    ui.msg.classList.add("show");
    clearTimeout(toast._t);
    toast._t = setTimeout(()=>ui.msg.classList.remove("show"), 1200);
  }

  const GAME = { zone:"start", hp:10, hpMax:10, wood:0, stone:0 };
  function sync(){
    ui.zoneChip.textContent = "Zone: " + (GAME.zone === "start" ? "Start" : "Dungeon");
    ui.hpText.textContent = `${GAME.hp}/${GAME.hpMax}`;
    ui.hpFill.style.width = `${(GAME.hp/GAME.hpMax)*100}%`;
    ui.woodText.textContent = GAME.wood;
    ui.stoneText.textContent = GAME.stone;
  }
  sync();

  // Canvas
  const wrap = document.getElementById("wrap");
  const canvas = document.createElement("canvas");
  canvas.id = "game";
  wrap.appendChild(canvas);

  const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer:false, stencil:true });
  const scene = new BABYLON.Scene(engine);
  scene.clearColor = new BABYLON.Color4(0,0,0,0);

  // Lighting (simple anime-ish)
  scene.ambientColor = new BABYLON.Color3(0.35,0.42,0.60);
  const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene);
  hemi.intensity = 0.95;

  const sun = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-0.4,-1,-0.3), scene);
  sun.position = new BABYLON.Vector3(20,35,20);
  sun.intensity = 1.15;

  // Camera: cinematic follow (NO MOUSE)
  const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(0,12,22), scene);
  camera.setTarget(new BABYLON.Vector3(0,2,0));
  camera.attachControl(canvas, false);      // keep it attached for resize, but no inputs
  camera.inputs.clear();                    // removes mouse/keyboard camera controls completely

  // Materials
  const matGroundStart = new BABYLON.StandardMaterial("g1", scene);
  matGroundStart.diffuseColor = new BABYLON.Color3(0.08,0.11,0.20);
  matGroundStart.specularColor = new BABYLON.Color3(0.05,0.05,0.05);

  const matGroundDung = new BABYLON.StandardMaterial("g2", scene);
  matGroundDung.diffuseColor = new BABYLON.Color3(0.05,0.06,0.10);
  matGroundDung.specularColor = new BABYLON.Color3(0.05,0.05,0.05);

  const matPlayer = new BABYLON.StandardMaterial("p", scene);
  matPlayer.diffuseColor = new BABYLON.Color3(0.86,0.90,1.0);
  matPlayer.specularColor = new BABYLON.Color3(0.05,0.05,0.05);

  const matHead = new BABYLON.StandardMaterial("h", scene);
  matHead.diffuseColor = new BABYLON.Color3(0.62,0.72,1.0);
  matHead.specularColor = new BABYLON.Color3(0.05,0.05,0.05);

  const matPortal = new BABYLON.StandardMaterial("portal", scene);
  matPortal.emissiveColor = new BABYLON.Color3(0.2, 1.0, 0.75);
  matPortal.alpha = 0.85;

  const matCrate = new BABYLON.StandardMaterial("crate", scene);
  matCrate.diffuseColor = new BABYLON.Color3(0.46,0.32,0.18);
  matCrate.specularColor = new BABYLON.Color3(0.05,0.05,0.05);

  const matLootWood = new BABYLON.StandardMaterial("lw", scene);
  matLootWood.emissiveColor = new BABYLON.Color3(0.4,1.0,0.75);

  const matLootStone = new BABYLON.StandardMaterial("ls", scene);
  matLootStone.emissiveColor = new BABYLON.Color3(1.0,0.82,0.40);

  // Groups via TransformNodes
  const startRoot = new BABYLON.TransformNode("startRoot", scene);
  const dungRoot  = new BABYLON.TransformNode("dungRoot", scene);
  dungRoot.setEnabled(false);

  // Ground start
  const groundStart = BABYLON.MeshBuilder.CreateGround("groundStart", { width:220, height:220 }, scene);
  groundStart.material = matGroundStart;
  groundStart.parent = startRoot;

  // Ground dungeon
  const groundDung = BABYLON.MeshBuilder.CreateGround("groundDung", { width:110, height:240 }, scene);
  groundDung.position.z = -140;
  groundDung.material = matGroundDung;
  groundDung.parent = dungRoot;

  // Portal (start)
  const portal = BABYLON.MeshBuilder.CreateTorus("portal", { diameter:10, thickness:0.55, tessellation:40 }, scene);
  portal.rotation.x = Math.PI/2;
  portal.position = new BABYLON.Vector3(0,3.6,-70);
  portal.material = matPortal;
  portal.parent = startRoot;

  const portalDisc = BABYLON.MeshBuilder.CreateDisc("portalDisc", { radius:4.2, tessellation:48 }, scene);
  portalDisc.rotation.x = Math.PI/2;
  portalDisc.position = new BABYLON.Vector3(0,3.6,-70);
  portalDisc.material = matPortal;
  portalDisc.parent = startRoot;

  const portalLight = new BABYLON.PointLight("pLight", new BABYLON.Vector3(0,3.8,-70), scene);
  portalLight.intensity = 1.25;
  portalLight.diffuse = new BABYLON.Color3(0.3, 1.0, 0.8);
  portalLight.parent = startRoot;

  // Player (simple capsule-ish)
  const player = new BABYLON.TransformNode("player", scene);
  player.position = new BABYLON.Vector3(0,0,40);

  const body = BABYLON.MeshBuilder.CreateCylinder("body", { height:2.2, diameter:1.25, tessellation:20 }, scene);
  body.position.y = 1.1;
  body.material = matPlayer;
  body.parent = player;

  const head = BABYLON.MeshBuilder.CreateSphere("head", { diameter:0.95, segments:20 }, scene);
  head.position.y = 2.35;
  head.material = matHead;
  head.parent = player;

  // Dungeon crates
  const breakables = [];
  function spawnCrate(x,z){
    const c = BABYLON.MeshBuilder.CreateBox("crate", { size:1.6 }, scene);
    c.position = new BABYLON.Vector3(x, 0.8, z);
    c.material = matCrate;
    c.parent = dungRoot;
    c.metadata = { hp:2 };
    breakables.push(c);
  }
  for (let i=0;i<12;i++){
    spawnCrate((Math.random()-0.5)*22, -200 + (Math.random()-0.5)*22);
  }

  // Loot
  const loots = [];
  function spawnLoot(type, x,z){
    const s = BABYLON.MeshBuilder.CreateSphere("loot", { diameter:0.7, segments:14 }, scene);
    s.position = new BABYLON.Vector3(x, 1.25, z);
    s.material = (type==="wood") ? matLootWood : matLootStone;
    s.parent = dungRoot;
    s.metadata = { type, t: Math.random()*10 };
    loots.push(s);
  }

  // Keyboard input (ONLY)
  const keys = new Set();
  window.addEventListener("keydown", (e)=>{
    const k = e.key.toLowerCase();
    keys.add(k);

    // Space attack only
    if (e.code === "Space"){
      e.preventDefault();
      doAttack();
    }
  });
  window.addEventListener("keyup", (e)=> keys.delete(e.key.toLowerCase()));

  // Movement + camera follow
  let vel = new BABYLON.Vector3(0,0,0);
  const tmp = new BABYLON.Vector3();

  // Fixed orientation: forward = -Z in world (so Up goes toward -Z).
  // Camera just follows behind the player, facing them toward travel direction.
  let faceYaw = 0; // radians

  function expDamp(a,b,lambda,dt){ return a + (b-a)*(1 - Math.exp(-lambda*dt)); }

  // Zone switch
  function setZone(z){
    if (GAME.zone === z) return;
    GAME.zone = z;
    if (z === "dungeon"){
      startRoot.setEnabled(false);
      dungRoot.setEnabled(true);
      player.position = new BABYLON.Vector3(0,0,-135);
      toast("Entered the dungeon.");
    } else {
      startRoot.setEnabled(true);
      dungRoot.setEnabled(false);
      player.position = new BABYLON.Vector3(0,0,-55);
      toast("Returned to start.");
    }
    sync();
  }

  // Attack
  let attackCd = 0;
  function doAttack(){
    if (attackCd > 0) return;
    attackCd = 0.22;

    // Only in dungeon
    if (GAME.zone !== "dungeon") return;

    const hitR = 2.9;
    const hitR2 = hitR*hitR;

    for (let i=breakables.length-1; i>=0; i--){
      const b = breakables[i];
      if (!b || b.isDisposed()) { breakables.splice(i,1); continue; }

      const dx = b.position.x - player.position.x;
      const dz = b.position.z - player.position.z;
      const d2 = dx*dx + dz*dz;

      if (d2 <= hitR2){
        b.metadata.hp -= 1;

        // tiny hit reaction
        b.position.x += (Math.random()<0.5?-0.12:0.12);
        b.position.z += (Math.random()<0.5?-0.12:0.12);

        if (b.metadata.hp <= 0){
          // drop loot
          spawnLoot("wood", b.position.x + (Math.random()-0.5)*0.8, b.position.z + (Math.random()-0.5)*0.8);
          if (Math.random() < 0.65) spawnLoot("stone", b.position.x + (Math.random()-0.5)*0.8, b.position.z + (Math.random()-0.5)*0.8);

          b.dispose();
          breakables.splice(i,1);
        }
      }
    }
  }

  // Main loop
  toast("Keyboard only: WASD/Arrows to move. Space to attack. Walk into portal.");

  engine.runRenderLoop(() => {
    const dt = engine.getDeltaTime() / 1000;
    attackCd = Math.max(0, attackCd - dt);

    // -------- movement input (CORRECT, NOT REVERSED) --------
    // world axes: +X right, -Z forward (classic)
    let mx = 0, mz = 0;

    // Forward/back (Up = forward = -Z)
    if (keys.has("w") || keys.has("arrowup"))    mz -= 1;
    if (keys.has("s") || keys.has("arrowdown"))  mz += 1;

    // Left/right (Left = -X)
    if (keys.has("a") || keys.has("arrowleft"))  mx -= 1;
    if (keys.has("d") || keys.has("arrowright")) mx += 1;

    tmp.set(mx, 0, mz);
    if (tmp.lengthSquared() > 0.0001) tmp.normalize();

    const sprint = keys.has("shift");
    const maxSpeed = sprint ? 10.0 : 7.4;

    // Smooth velocity
    const wishX = tmp.x * maxSpeed;
    const wishZ = tmp.z * maxSpeed;
    vel.x = expDamp(vel.x, wishX, 22.0, dt);
    vel.z = expDamp(vel.z, wishZ, 22.0, dt);

    player.position.x += vel.x * dt;
    player.position.z += vel.z * dt;

    // Face movement direction (if moving)
    const planar = Math.hypot(vel.x, vel.z);
    if (planar > 0.25){
      faceYaw = Math.atan2(vel.x, vel.z); // correct for X/Z
      player.rotation.y = expDamp(player.rotation.y, faceYaw, 18.0, dt);
    }

    // Bounds + portal triggers
    if (GAME.zone === "start"){
      player.position.x = BABYLON.Scalar.Clamp(player.position.x, -80, 80);
      player.position.z = BABYLON.Scalar.Clamp(player.position.z, -95, 75);

      // portal trigger
      const dx = player.position.x - 0;
      const dz = player.position.z - (-70);
      if (dx*dx + dz*dz < (4.6*4.6)) setZone("dungeon");

      // portal animation
      portal.rotation.z += dt * 0.6;
      portalDisc.rotation.z -= dt * 0.35;
    } else {
      player.position.x = BABYLON.Scalar.Clamp(player.position.x, -28, 28);
      player.position.z = BABYLON.Scalar.Clamp(player.position.z, -240, -115);

      // exit trigger
      const dx = player.position.x - 0;
      const dz = player.position.z - (-120);
      if (dx*dx + dz*dz < (5.0*5.0)) setZone("start");

      // Loot magnet + bob + collect
      const MAGNET_R = 2.6;
      const MAGNET_R2 = MAGNET_R*MAGNET_R;

      for (let i=loots.length-1; i>=0; i--){
        const L = loots[i];
        if (!L || L.isDisposed()) { loots.splice(i,1); continue; }

        L.metadata.t += dt;
        L.position.y = 1.25 + Math.sin(L.metadata.t*3.4)*0.16;

        const lx = L.position.x, lz = L.position.z;
        const ddx = player.position.x - lx;
        const ddz = player.position.z - lz;
        const d2 = ddx*ddx + ddz*ddz;

        if (d2 < MAGNET_R2){
          // pull
          L.position.x = expDamp(L.position.x, player.position.x, 18.0, dt);
          L.position.z = expDamp(L.position.z, player.position.z, 18.0, dt);

          if (d2 < 0.45*0.45){
            if (L.metadata.type === "wood") GAME.wood += 1;
            else GAME.stone += 1;
            sync();
            L.dispose();
            loots.splice(i,1);
          }
        }
      }
    }

    // -------- cinematic follow camera (NO MOUSE) --------
    // Wide + smooth follow behind player based on facing yaw
    const dist = 20.0;
    const height = 9.0;

    const yaw = player.rotation.y;
    const camX = player.position.x + Math.sin(yaw) * dist;
    const camZ = player.position.z + Math.cos(yaw) * dist;

    camera.position.x = expDamp(camera.position.x, camX, 8.0, dt);
    camera.position.y = expDamp(camera.position.y, height, 8.0, dt);
    camera.position.z = expDamp(camera.position.z, camZ, 8.0, dt);

    const target = new BABYLON.Vector3(
      expDamp(camera.getTarget().x, player.position.x, 11.0, dt),
      expDamp(camera.getTarget().y, 1.8, 11.0, dt),
      expDamp(camera.getTarget().z, player.position.z, 11.0, dt)
    );
    camera.setTarget(target);

    scene.render();
  });

  window.addEventListener("resize", () => engine.resize());
})();
</script>
</body>
</html>
