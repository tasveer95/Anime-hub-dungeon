<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Anime Hub ‚Üí Dungeon (Babylon Improved)</title>
  <style>
    :root{
      --glass: rgba(10,14,26,.72);
      --stroke: rgba(255,255,255,.14);
      --text: rgba(238,243,255,.92);
      --muted: rgba(238,243,255,.72);
      --good: rgba(102,242,185,.95);
      --gold: rgba(255,208,102,.95);
      --danger: rgba(255,118,118,.95);
      --shadow: 0 18px 55px rgba(0,0,0,.45);
      --r: 18px;
    }
    html,body{height:100%;margin:0;overflow:hidden;background:#070A12;font-family:system-ui,Segoe UI,Roboto,Arial;color:var(--text);}
    #wrap{position:relative;width:100vw;height:100vh;}
    canvas{position:absolute;inset:0;width:100vw;height:100vh;display:block;}

    #hud{
      position:absolute;left:16px;top:16px;width:400px;z-index:5;
      background:var(--glass);border:1px solid var(--stroke);
      border-radius:var(--r);padding:14px;backdrop-filter:blur(10px);
      box-shadow:var(--shadow);user-select:none;
    }
    .row{display:flex;justify-content:space-between;align-items:center;gap:10px;}
    .title{font-weight:900;letter-spacing:.2px}
    .chip{padding:6px 10px;border-radius:999px;border:1px solid var(--stroke);background:rgba(255,255,255,.05);font-size:12px;color:var(--muted)}
    .barWrap{margin-top:10px;padding:10px;border-radius:14px;border:1px solid var(--stroke);background:rgba(255,255,255,.05)}
    .barLabel{font-size:12px;color:var(--muted);margin-bottom:6px}
    .hpBar{height:12px;border-radius:999px;background:rgba(255,255,255,.08);overflow:hidden;border:1px solid rgba(255,255,255,.10)}
    .hpFill{height:100%;width:100%;background:linear-gradient(90deg, rgba(255,90,90,.95), rgba(102,242,185,.95));}
    .cards{display:flex;gap:10px;margin-top:10px;flex-wrap:wrap}
    .card{flex:1;min-width:180px;padding:10px;border-radius:14px;border:1px solid var(--stroke);background:rgba(255,255,255,.05)}
    .k{font-size:12px;color:var(--muted);margin-bottom:4px}
    .v{font-size:14px;font-weight:800;display:flex;gap:8px;flex-wrap:wrap}
    .good{color:var(--good);font-weight:900}
    .gold{color:var(--gold);font-weight:900}
    .danger{color:var(--danger);font-weight:900}
    .hint{margin-top:10px;font-size:12px;color:var(--muted);line-height:1.35}

    #topRight{
      position:absolute;right:16px;top:16px;z-index:5;
      display:flex;flex-direction:column;gap:10px;
    }
    .counter{
      display:flex;align-items:center;justify-content:space-between;
      min-width:200px;padding:10px 12px;border-radius:16px;
      border:1px solid var(--stroke);background:var(--glass);backdrop-filter:blur(10px);
      box-shadow:var(--shadow);
    }
    .counterLeft{display:flex;align-items:center;gap:10px}
    .icon{
      width:22px;height:22px;border-radius:7px;
      background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);
      display:grid;place-items:center;
    }
    .count{font-weight:900;font-size:18px}
    .plus{
      width:26px;height:26px;border-radius:8px;
      border:1px solid rgba(255,255,255,.20);
      background:rgba(102,242,185,.12);
      display:flex;align-items:center;justify-content:center;
      color:var(--good);font-weight:900;
    }

    #attackBtn{
      position:absolute;right:22px;bottom:120px;width:120px;height:120px;border-radius:999px;z-index:5;
      border:1px solid rgba(255,255,255,.18);
      background:radial-gradient(circle at 40% 35%, rgba(255,220,140,.22), rgba(255,208,102,.08) 55%, rgba(10,14,26,.55));
      backdrop-filter:blur(10px);box-shadow:var(--shadow);
      display:flex;align-items:center;justify-content:center;cursor:pointer;user-select:none;
      touch-action:manipulation;
    }
    #attackBtn:active{transform:translateY(1px) scale(.99)}
    #attackBtn .inner{
      width:92px;height:92px;border-radius:999px;
      border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.06);
      display:flex;flex-direction:column;align-items:center;justify-content:center;gap:6px;
    }
    #attackBtn .lbl{font-weight:900;color:var(--gold)}
    #attackBtn .sub{font-size:11px;color:var(--muted);font-weight:700}

    #toast{
      position:absolute;left:50%;top:16px;transform:translateX(-50%);z-index:6;
      width:min(820px, calc(100vw - 30px));
      padding:10px 14px;border-radius:16px;border:1px solid var(--stroke);
      background:rgba(10,14,26,.65);backdrop-filter:blur(10px);
      box-shadow:var(--shadow);text-align:center;
      opacity:0;transition:opacity .18s ease;
      color:rgba(235,241,255,.82);font-weight:800;
      pointer-events:none;
    }
    #toast.show{opacity:1}
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="game"></canvas>

  <div id="toast"></div>

  <div id="hud">
    <div class="row">
      <div class="title">Prototype</div>
      <div class="chip" id="zoneChip">Zone: Start</div>
    </div>

    <div class="barWrap">
      <div class="barLabel">HP <span class="gold" id="hpText">10/10</span></div>
      <div class="hpBar"><div class="hpFill" id="hpFill"></div></div>
    </div>

    <div class="cards">
      <div class="card">
        <div class="k">Resources</div>
        <div class="v">
          <span class="gold"><span id="woodText">0</span></span> wood ¬∑
          <span class="gold"><span id="stoneText">0</span></span> stone
        </div>
      </div>
      <div class="card">
        <div class="k">Controls</div>
        <div class="v">
          <span class="good">WASD</span>/<span class="good">Arrows</span>
          <span class="good">Shift</span> Sprint
        </div>
      </div>
    </div>

    <div class="hint">
      Attack: <span class="good">Space / Click / Tap</span> ¬∑ Camera: <span class="good">Mouse drag</span><br/>
      Walk into the <span class="gold">glowing portal</span> to reach the dungeon.
    </div>
  </div>

  <div id="topRight">
    <div class="counter">
      <div class="counterLeft">
        <span class="icon">ü™µ</span>
        <div class="count" id="woodCount">0</div>
      </div>
      <div class="plus">+</div>
    </div>
    <div class="counter">
      <div class="counterLeft">
        <span class="icon">ü™®</span>
        <div class="count" id="stoneCount">0</div>
      </div>
      <div class="plus">+</div>
    </div>
  </div>

  <div id="attackBtn" aria-label="Attack">
    <div class="inner">
      <div style="font-size:26px">üó°Ô∏è</div>
      <div class="lbl">Attack</div>
      <div class="sub">Space / Tap</div>
    </div>
  </div>
</div>

<script src="https://cdn.babylonjs.com/babylon.js"></script>

<script>
(() => {
  const ui = {
    toast: document.getElementById("toast"),
    zoneChip: document.getElementById("zoneChip"),
    hpText: document.getElementById("hpText"),
    hpFill: document.getElementById("hpFill"),
    woodText: document.getElementById("woodText"),
    stoneText: document.getElementById("stoneText"),
    woodCount: document.getElementById("woodCount"),
    stoneCount: document.getElementById("stoneCount"),
    attackBtn: document.getElementById("attackBtn"),
  };

  function showToast(msg){
    ui.toast.textContent = msg;
    ui.toast.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>ui.toast.classList.remove("show"), 1600);
  }
  function fatal(msg){
    console.error(msg);
    ui.toast.textContent = "‚ùå " + msg;
    ui.toast.classList.add("show");
  }
  window.addEventListener("error", (e)=>fatal(e.message || "Unknown JS error"));
  window.addEventListener("unhandledrejection", (e)=>fatal((e.reason && e.reason.message) ? e.reason.message : "Promise error"));

  if (!window.BABYLON){ fatal("Babylon.js failed to load (CDN blocked). Disable adblock/shields and reload."); return; }
  if (!BABYLON.Engine.isSupported()){ fatal("WebGL not supported/disabled. Enable hardware acceleration and relaunch Chrome."); return; }

  // ===== GAME STATE =====
  const GAME = { zone:"start", hp:10, hpMax:10, wood:0, stone:0 };
  function syncUI(){
    ui.zoneChip.textContent = "Zone: " + (GAME.zone === "start" ? "Start" : "Dungeon");
    ui.hpText.textContent = `${GAME.hp}/${GAME.hpMax}`;
    ui.hpFill.style.width = `${(GAME.hp/GAME.hpMax)*100}%`;
    ui.woodText.textContent = GAME.wood;
    ui.stoneText.textContent = GAME.stone;
    ui.woodCount.textContent = GAME.wood;
    ui.stoneCount.textContent = GAME.stone;
  }
  syncUI();

  // ===== SETUP =====
  const canvas = document.getElementById("game");
  const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer:false, stencil:false });

  const scene = new BABYLON.Scene(engine);
  scene.clearColor = new BABYLON.Color4(0.03, 0.04, 0.08, 1);
  scene.collisionsEnabled = true;

  // Fog cinematic
  scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
  scene.fogDensity = 0.010;
  scene.fogColor = new BABYLON.Color3(0.05,0.08,0.16);

  // Lights
  const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene);
  hemi.intensity = 0.95;

  const sun = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-0.4,-1,-0.25), scene);
  sun.position = new BABYLON.Vector3(20,30,20);
  sun.intensity = 1.2;

  function flatMat(hex){
    const m = new BABYLON.StandardMaterial("m_"+hex, scene);
    const c = BABYLON.Color3.FromHexString(hex);
    m.diffuseColor = c;
    m.specularColor = new BABYLON.Color3(0.06,0.06,0.06);
    m.emissiveColor = c.scale(0.10);
    return m;
  }

  // ===== 3rd-person follow camera rig (smooth) =====
  // We still use ArcRotate for easy mouse drag, but we *drive* it toward target values for "follow cam feel".
  const camera = new BABYLON.ArcRotateCamera(
    "cam",
    BABYLON.Tools.ToRadians(180),
    BABYLON.Tools.ToRadians(62),
    22,
    new BABYLON.Vector3(0,1.6,0),
    scene
  );
  camera.lowerRadiusLimit = 14;
  camera.upperRadiusLimit = 34;
  camera.panningSensibility = 0;
  camera.inertia = 0.0; // we do our own smoothing
  camera.attachControl(canvas, true);

  // Desired camera settings (cinematic follow)
  const camDesired = { alpha: camera.alpha, beta: camera.beta, radius: camera.radius };
  const camSmooth = 1 - Math.exp(-10 * 0.016);

  // ===== WORLD ROOTS =====
  const startRoot = new BABYLON.TransformNode("startRoot", scene);
  const dungeonRoot = new BABYLON.TransformNode("dungeonRoot", scene);
  dungeonRoot.setEnabled(false);

  // ===== START ZONE =====
  const startGround = BABYLON.MeshBuilder.CreateGround("startGround", { width:220, height:220 }, scene);
  startGround.parent = startRoot;
  startGround.checkCollisions = true;
  startGround.material = flatMat("#1b2a55");

  // Visual anchors (helps user immediately)
  const startMarker = BABYLON.MeshBuilder.CreateBox("startMarker", { size:1.2 }, scene);
  startMarker.parent = startRoot;
  startMarker.position = new BABYLON.Vector3(0, 0.6, 28);
  startMarker.material = flatMat("#ff4d6d");

  // Portal Gate
  const gate = new BABYLON.TransformNode("gate", scene);
  gate.parent = startRoot;
  gate.position = new BABYLON.Vector3(0,0,-70);

  const ring = BABYLON.MeshBuilder.CreateTorus("ring",{ diameter:10.6, thickness:0.75, tessellation:48 }, scene);
  ring.parent = gate;
  ring.rotation.x = Math.PI/2;
  ring.position.y = 3.6;
  ring.material = flatMat("#6a7db0");

  const portal = BABYLON.MeshBuilder.CreateDisc("portal",{ radius:4.3, tessellation:64 }, scene);
  portal.parent = gate;
  portal.rotation.x = Math.PI/2;
  portal.position.y = 3.6;

  const portalMat = flatMat("#0a1020");
  portalMat.emissiveColor = BABYLON.Color3.FromHexString("#66f2b9").scale(2.1);
  portal.material = portalMat;

  const portalLight = new BABYLON.PointLight("portalLight", new BABYLON.Vector3(0,3.6,-70), scene);
  portalLight.diffuse = BABYLON.Color3.FromHexString("#66f2b9");
  portalLight.intensity = 1.4;
  portalLight.range = 30;

  // ===== DUNGEON =====
  const dungeonFloor = BABYLON.MeshBuilder.CreateGround("dungeonFloor", { width:110, height:240 }, scene);
  dungeonFloor.parent = dungeonRoot;
  dungeonFloor.position = new BABYLON.Vector3(0,0,-140);
  dungeonFloor.checkCollisions = true;
  dungeonFloor.material = flatMat("#0f1220");

  function wall(x,y,z,w,h,d){
    const m = BABYLON.MeshBuilder.CreateBox("wall",{ width:w, height:h, depth:d }, scene);
    m.position = new BABYLON.Vector3(x,y,z);
    m.material = flatMat("#1a2240");
    m.checkCollisions = true;
    m.parent = dungeonRoot;
    return m;
  }
  wall(-14, 2.7, -110, 2.5, 5.4, 90);
  wall( 14, 2.7, -110, 2.5, 5.4, 90);

  // ===== PLAYER =====
  const player = BABYLON.MeshBuilder.CreateCylinder("player",{ height:1.9, diameter:1.2, tessellation:16 }, scene);
  player.position = new BABYLON.Vector3(0, 1.0, 40);
  player.material = flatMat("#D6E1FF");
  player.checkCollisions = true;
  player.ellipsoid = new BABYLON.Vector3(0.55, 0.95, 0.55);
  player.ellipsoidOffset = new BABYLON.Vector3(0, 0.95, 0);
  camera.target = player.position.clone();

  const head = BABYLON.MeshBuilder.CreateSphere("head",{ diameter:0.85, segments:16 }, scene);
  head.parent = player;
  head.position = new BABYLON.Vector3(0, 0.95, 0);
  head.material = flatMat("#A9C2FF");

  // tiny buddy
  const buddy = BABYLON.MeshBuilder.CreateSphere("buddy",{ diameter:0.35, segments:12 }, scene);
  buddy.parent = player;
  buddy.position = new BABYLON.Vector3(-0.9, 0.55, 0.25);
  const buddyMat = flatMat("#66f2b9");
  buddyMat.emissiveColor = BABYLON.Color3.FromHexString("#66f2b9").scale(0.8);
  buddy.material = buddyMat;

  // ===== BREAKABLES + LOOT =====
  const breakables = [];
  const loot = [];

  function spawnCrate(root, x, z){
    const c = BABYLON.MeshBuilder.CreateBox("crate",{ size:1.6 }, scene);
    c.position = new BABYLON.Vector3(x, 0.8, z);
    c.material = flatMat("#7b5630");
    c.checkCollisions = true;
    c.metadata = { hp: 2 };
    c.parent = root;
    breakables.push(c);
    return c;
  }

  // test crate in start
  spawnCrate(startRoot, 4, 34);
  // dungeon crates
  for (let i=0;i<12;i++){
    spawnCrate(dungeonRoot, (Math.random()-0.5)*22, -200 + (Math.random()-0.5)*22);
  }

  function spawnLoot(type, x, z, root){
    const s = BABYLON.MeshBuilder.CreateSphere("loot",{ diameter:0.65, segments:12 }, scene);
    s.position = new BABYLON.Vector3(x, 1.35, z);
    const mat = flatMat(type==="wood" ? "#66f2b9" : "#ffd066");
    mat.emissiveColor = BABYLON.Color3.FromHexString(type==="wood" ? "#66f2b9" : "#ffd066").scale(1.25);
    s.material = mat;
    s.parent = root;

    const l = new BABYLON.PointLight("lootLight", s.position.clone(), scene);
    l.diffuse = BABYLON.Color3.FromHexString(type==="wood" ? "#66f2b9" : "#ffd066");
    l.intensity = 0.95;
    l.range = 14;

    loot.push({ type, mesh:s, light:l, t:Math.random()*10, root });
  }

  // ===== INPUT =====
  const keys = new Set();
  window.addEventListener("keydown", (e)=>keys.add(e.key.toLowerCase()));
  window.addEventListener("keyup", (e)=>keys.delete(e.key.toLowerCase()));

  // ===== MOVEMENT (PROPER, NOT REVERSED) =====
  // We use a smoothed velocity to remove "jank".
  let vx = 0, vz = 0;

  function damp(cur, target, lambda, dt){
    return cur + (target-cur) * (1 - Math.exp(-lambda*dt));
  }

  // ===== ATTACK (cone in front + slash VFX) =====
  let attackCd = 0;

  function slashVFX(){
    // A quick ring arc in front of player
    const arc = BABYLON.MeshBuilder.CreateTorus("slash",{ diameter:3.2, thickness:0.14, tessellation:48 }, scene);
    arc.position = player.position.add(new BABYLON.Vector3(
      Math.sin(player.rotation.y) * 1.2,
      1.0,
      Math.cos(player.rotation.y) * 1.2
    ));
    arc.rotation = new BABYLON.Vector3(Math.PI/2, player.rotation.y, 0);

    const m = flatMat("#ffffff");
    m.emissiveColor = new BABYLON.Color3(1,1,1).scale(1.2);
    m.alpha = 0.55;
    arc.material = m;

    let t = 0;
    const obs = scene.onBeforeRenderObservable.add(() => {
      const dt = engine.getDeltaTime()/1000;
      t += dt;
      arc.scaling.scaleInPlace(1 + dt*1.8);
      m.alpha = Math.max(0, 0.55*(1 - t/0.18));
      if (t >= 0.18){
        scene.onBeforeRenderObservable.remove(obs);
        arc.dispose();
        m.dispose();
      }
    });
  }

  function doAttack(){
    if (attackCd > 0) return;
    attackCd = 0.24;
    slashVFX();

    // Attack cone: forward only
    const range = 3.0;
    const coneCos = Math.cos(BABYLON.Tools.ToRadians(65)); // ~65¬∞ cone

    const fwd = new BABYLON.Vector3(
      Math.sin(player.rotation.y),
      0,
      Math.cos(player.rotation.y)
    ).normalize();

    const activeRoot = (GAME.zone === "start") ? startRoot : dungeonRoot;

    for (let i=breakables.length-1;i>=0;i--){
      const b = breakables[i];
      if (!b || b.isDisposed()){ breakables.splice(i,1); continue; }
      if (b.parent !== activeRoot) continue;

      const to = b.position.subtract(player.position);
      to.y = 0;
      const dist = to.length();
      if (dist > range) continue;

      const dir = to.normalize();
      const dot = BABYLON.Vector3.Dot(fwd, dir);
      if (dot < coneCos) continue; // must be in front cone

      b.metadata.hp -= 1;

      // hit feedback
      b.position.x += (Math.random()<0.5?-0.16:0.16);
      b.position.z += (Math.random()<0.5?-0.16:0.16);

      if (b.metadata.hp <= 0){
        const bx=b.position.x, bz=b.position.z;

        // drop loot into the CURRENT zone root
        spawnLoot("wood", bx+(Math.random()-0.5)*0.8, bz+(Math.random()-0.5)*0.8, activeRoot);
        if (Math.random()<0.65) spawnLoot("stone", bx+(Math.random()-0.5)*0.8, bz+(Math.random()-0.5)*0.8, activeRoot);

        b.dispose();
        breakables.splice(i,1);
      }
    }
  }

  window.addEventListener("keydown", (e)=>{ if (e.code==="Space"){ e.preventDefault(); doAttack(); }});
  window.addEventListener("pointerdown", (e)=>{ if (e.button === 0) doAttack(); });
  ui.attackBtn.addEventListener("pointerdown", (e)=>{ e.preventDefault(); doAttack(); });

  // ===== ZONE SWITCH =====
  function setZone(zone){
    if (GAME.zone === zone) return;
    GAME.zone = zone;

    if (zone === "dungeon"){
      startRoot.setEnabled(false);
      dungeonRoot.setEnabled(true);

      // mood shift
      scene.fogDensity = 0.017;
      scene.fogColor = new BABYLON.Color3(0.02,0.03,0.07);

      player.position = new BABYLON.Vector3(0, 1.0, -135);
      camDesired.radius = 22;
      camDesired.beta = BABYLON.Tools.ToRadians(62);

      showToast("Entered the dungeon.");
    } else {
      startRoot.setEnabled(true);
      dungeonRoot.setEnabled(false);

      scene.fogDensity = 0.010;
      scene.fogColor = new BABYLON.Color3(0.05,0.08,0.16);

      player.position = new BABYLON.Vector3(0, 1.0, 40);
      camDesired.radius = 22;
      camDesired.beta = BABYLON.Tools.ToRadians(62);

      showToast("Back in the hub.");
    }
    syncUI();
  }

  // ===== MAIN LOOP =====
  showToast("Move: WASD/Arrows. Attack: Space/Click. Walk into the glowing portal.");
  let last = performance.now();

  scene.onBeforeRenderObservable.add(() => {
    const now = performance.now();
    const dt = Math.min(0.05, (now - last)/1000);
    last = now;

    // Animate portal pulse
    portalMat.emissiveColor = BABYLON.Color3.FromHexString("#66f2b9").scale(1.6 + 0.9*Math.sin(now*0.003));

    // Buddy bob
    buddy.position.y = 0.55 + Math.sin(now*0.006)*0.06;

    // attack cooldown
    attackCd = Math.max(0, attackCd - dt);

    // Read input (FIXED: NOT REVERSED)
    // Left = left, Up = forward
    let mx=0, mz=0;
    if (keys.has("a") || keys.has("arrowleft"))  mx -= 1;
    if (keys.has("d") || keys.has("arrowright")) mx += 1;
    if (keys.has("w") || keys.has("arrowup"))    mz += 1;
    if (keys.has("s") || keys.has("arrowdown"))  mz -= 1;

    const len = Math.hypot(mx,mz);
    if (len > 0){ mx/=len; mz/=len; }

    const sprint = keys.has("shift");
    const speed = sprint ? 10.4 : 7.8;

    // Camera-relative move vector (ArcRotate alpha)
    const yaw = camera.alpha;

    // Forward direction on ground plane (where camera "faces")
    const forward = new BABYLON.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw)).normalize();
    const right   = new BABYLON.Vector3(forward.z, 0, -forward.x).normalize();

    const wish = right.scale(mx).add(forward.scale(mz)).scale(speed);

    // Smooth velocity (secrets: eliminates drift + feels console-like)
    vx = damp(vx, wish.x, 18.0, dt);
    vz = damp(vz, wish.z, 18.0, dt);

    player.moveWithCollisions(new BABYLON.Vector3(vx*dt, 0, vz*dt));

    // Face travel direction (only if moving)
    const vlen = Math.hypot(vx,vz);
    if (vlen > 0.3){
      const face = Math.atan2(vx, vz);
      player.rotation.y = BABYLON.Scalar.LerpAngle(player.rotation.y, face, 0.22);
    }

    // True follow camera feel: we gently steer camera alpha behind player
    // (keeps cinematic framing while still allowing mouse drag)
    const followStrength = 0.035;
    camDesired.alpha = BABYLON.Scalar.LerpAngle(camDesired.alpha, player.rotation.y + Math.PI, followStrength);

    // Apply smoothing to camera
    camera.alpha  = BABYLON.Scalar.LerpAngle(camera.alpha, camDesired.alpha, 0.12);
    camera.beta   = BABYLON.Scalar.Lerp(camera.beta, camDesired.beta, 0.12);
    camera.radius = BABYLON.Scalar.Lerp(camera.radius, camDesired.radius, 0.12);
    camera.target = BABYLON.Vector3.Lerp(camera.target, player.position.add(new BABYLON.Vector3(0,1.6,0)), 0.18);

    // Portal trigger
    if (GAME.zone === "start"){
      const gx = gate.getAbsolutePosition().x;
      const gz = gate.getAbsolutePosition().z;
      const dx = player.position.x - gx;
      const dz = player.position.z - gz;
      if (dx*dx + dz*dz < 4.7*4.7){
        setZone("dungeon");
      }
    }

    // Loot magnet + pickup (only collects in CURRENT zone)
    const activeRoot = (GAME.zone === "start") ? startRoot : dungeonRoot;
    const MAG = 2.7;

    for (let i=loot.length-1;i>=0;i--){
      const p = loot[i];
      if (!p.mesh || p.mesh.isDisposed()){ loot.splice(i,1); continue; }

      // Only magnet/pickup loot in the current root
      if (p.root !== activeRoot) continue;

      p.t += dt;
      p.mesh.position.y = 1.35 + Math.sin(p.t*3.2)*0.16;
      p.light.position.copyFrom(p.mesh.position);

      const d = BABYLON.Vector3.Distance(player.position, p.mesh.position);

      if (d < MAG){
        p.mesh.position.x = BABYLON.Scalar.Lerp(p.mesh.position.x, player.position.x, 0.18);
        p.mesh.position.z = BABYLON.Scalar.Lerp(p.mesh.position.z, player.position.z, 0.18);

        if (d < 0.55){
          if (p.type === "wood") GAME.wood += 1;
          else GAME.stone += 1;

          p.light.dispose();
          p.mesh.dispose();
          loot.splice(i,1);
          syncUI();
        }
      }
    }
  });

  engine.runRenderLoop(() => scene.render());
  window.addEventListener("resize", () => engine.resize());
})();
</script>
</body>
</html>
